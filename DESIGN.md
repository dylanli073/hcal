# Design #

Vincent Li, Anna Lou, Dylan Li  
  
HCAL is a web application developed using the Flask microframework for Python. It incorporates the Gmail API, Google Calendar API, and parsedatetime library implemented previously by a github user to search through emails and compile event times into a Google Calendar. Additionally, Bootstrap libraries were used to stylize the web application.  

First and foremost, HCAL uses the Gmail API for access to a Gmail account that has been set up to receive emails from various mailing lists. Although IMAP has been a popular email protocol for many years, we decided to use Gmail API, since it is more efficient and tailored for use with Gmail in particular. To enable the Flask app to access a user’s Google account, we used the OAuth 2.0 authorization protocol, which required different authorization for calendar and for gmail. Initially, we had used an older authorization method involving httplib2 and a similar oauth2client in Python; however, this method proved to be incompatible with Flask. As a result, we had to switch to another OAuth 2.0 authorization protocol, which involved storing user credentials inside the Flask session. In addition, our program has the ability to transfer events from one calendar to another (personal one).  

For retrieving event information from emails, we had initially envisioned using BeautifulSoup, a Python library, to scrape emails according to their HTML tags. However, we soon realized that there is no standardized format for emails sent by organizations and mailing lists at Harvard. As a result, we found that scraping emails for content was much more difficult than initially anticipated. Instead of looking for specific tags in emails with BeautifulSoup, we decided to implement a search algorithm (called “parseGmail()” in our “helpers.py” file) to parse emails for indications of datetime. We accomplished this by incorporating the parsedatetime Python package. To look through the rather complicated structure of a Gmail message, we implemented Python functions to return the dictionary-like contents of a sample message and analyzed these contents using an online JSON editor for easy viewing and a Base64 Decoder to view the messages in UTF-8 (rather than base 64). In this process, we realized that again, there was no standardized format for parsing location in a message, so we chose to use a series of “try and except” statements in the “GetMimeMessage” function to find the information contained in each message.  

Once we obtained the text in the subject and in the body, we implemented our parsing algorithm to find instances of datetime. Specifically, we used parsedatetime to first search the subject for datetime and if we found a datetime, we used the Google Calendar API to add an event to the user’s calendar, with the parsed datetime as the event start time and the subject of the message as the event name. If our parsed datetime was around the same time as the current time (within 60 seconds, specifically), we would know that there was no datetime found in the message subject by parsedatetime, since parsedatetime returns the current time if no datetime is found. For the second part of our algorithm, if we did not find a datetime in the subject, we would search the message body for a datetime, and if it wasn’t, we would know that this message probably did not contain an event, so it would not be added to the calendar.  

One limitation of our parsing algorithm is that the parsedatetime library only searches for the first instance of a datetime, meaning that both a start time and end time cannot be found for an event. Although the “quickAdd event” function of the Google Calendar API could parse for both start and end times, through testing, we found that this function was more inaccurate than parsedatetime. As a result, we chose to use parsedatetime to find instances of datetime. In the future, we would like to improve the efficiency of our algorithm and perhaps also find a way to search for accurate event end time and event location.  

We chose to embed our calendar with Google Calendars because of the convenient parsing functions and online storage. We were already looking for ways to filter through the calendar that was to be displayed to the user, so when we analyzed the Google Calendar embed code and found that adding an additional calendar only added two additional phrases to the iframe, we decided to add a Filters section in the sidebar with toggles for calendars, each of which represented a mailing list. The additional phrases, however, included HTML character codes that were automatically rendered (e.g. “%23” became “#”) and caused an error, so we had to manually iterate through the strings and change them back in order for the iframe to function correctly.  

The sidebar also includes multiple views (week, month, agenda) for the user to select from. Visualizing the same calendar through different views is extremely useful for getting a better sense of the dates and times of surrounding events, so we added extra links to the side to ensure users wouldn’t miss them.  

Finally, using Heroku, we deployed our app to the following URL: http://hcal50.herokuapp.com.  